require('dotenv').config();
const express = require('express');
const session = require('express-session');
const bcrypt = require('bcrypt');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const path = require('path');

const app = express();
const PORT = process.env.PORT || 3000;

// Configura√ß√µes de ambiente
const ADMIN_USERNAME = process.env.ADMIN_USERNAME || 'admin';
const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'admin123';
const SESSION_SECRET = process.env.SESSION_SECRET || 'change-this-secret-in-production';
const MONGODB_URI = process.env.MONGODB_URI || 'mongodb+srv://mrjociriju_db_user:5BhRGBe2H9x4njC3@cluster0.kuihnel.mongodb.net/?appName=Cluster0';

// Logs de ambiente (√∫til para debug em produ√ß√£o)
console.log('\nüöÄ INICIANDO SERVIDOR - LOGS DE AMBIENTE');
console.log('='.repeat(60));
console.log(`üìç NODE_ENV: ${process.env.NODE_ENV || 'development'}`);
console.log(`üîå PORT: ${PORT}`);
console.log(`üë§ ADMIN_USERNAME: ${ADMIN_USERNAME}`);
console.log(`üîê SESSION_SECRET est√° definido: ${SESSION_SECRET ? 'Sim ‚úÖ' : 'N√£o ‚ùå'}`);
console.log(`üóÑÔ∏è  MONGODB_URI est√° definido: ${MONGODB_URI ? 'Sim ‚úÖ' : 'N√£o ‚ùå'}`);
console.log(`üóÑÔ∏è  Database name: history_interactive`);
console.log('='.repeat(60));
console.log('\nüîÑ Tentando conectar ao MongoDB Atlas...\n');

// Eventos do Mongoose para monitoramento
mongoose.connection.on('connecting', () => {
  console.log('‚è≥ Mongoose: Conectando ao MongoDB...');
});

mongoose.connection.on('connected', () => {
  console.log('‚úÖ Mongoose: Conex√£o estabelecida com sucesso!');
});

mongoose.connection.on('disconnected', () => {
  console.warn('‚ö†Ô∏è  Mongoose: Desconectado do MongoDB');
});

mongoose.connection.on('error', (err) => {
  console.error('‚ùå Mongoose Error:', err);
});

// Conectar ao MongoDB
mongoose.connect(MONGODB_URI, {
  dbName: 'history_interactive',
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
})
  .then(() => {
    console.log('üìö MongoDB Atlas conectado com sucesso!');
    console.log(`üì¶ Collections dispon√≠veis ser√£o criadas automaticamente\n`);
    initDatabase();
  })
  .catch((err) => {
    console.error('\n‚ùå ERRO CR√çTICO AO CONECTAR AO MONGODB:');
    console.error('='.repeat(60));
    console.error('Mensagem:', err.message);
    console.error('C√≥digo:', err.code);
    console.error('Nome:', err.name);
    console.error('='.repeat(60));
    console.error('\nüí° Poss√≠veis solu√ß√µes:');
    console.error('1. Verifique se o IP est√° na whitelist do MongoDB Atlas');
    console.error('2. Verifique se a senha est√° correta (sem caracteres especiais n√£o codificados)');
    console.error('3. Verifique se o cluster est√° ativo');
    console.error('4. Tente acessar: https://cloud.mongodb.com/');
    console.error('\n');
    process.exit(1);
  });

// ============================================
// SCHEMAS E MODELS DO MONGOOSE
// ============================================

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true }
});

const StorySchema = new mongoose.Schema({
  title: { type: String, required: true },
  description: String,
  cover_color: { type: String, default: '#2d2d2d' },
  cover_image: String,
  genre: { type: String, default: 'Drama Real' },
  status: { type: String, default: 'Em andamento' },
  date_created: { type: Date, default: Date.now },
  date_updated: { type: Date, default: Date.now }
});

const ChapterSchema = new mongoose.Schema({
  story_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Story', required: true },
  chapter_number: { type: Number, required: true },
  title: { type: String, required: true },
  content: { type: String, required: true },
  is_ending: { type: Boolean, default: false },
  date_created: { type: Date, default: Date.now }
});

const ChoiceSchema = new mongoose.Schema({
  chapter_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Chapter', required: true },
  choice_text: { type: String, required: true },
  next_chapter_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Chapter' },
  order_number: { type: Number, default: 0 }
});

const ReadingProgressSchema = new mongoose.Schema({
  session_id: { type: String, required: true },
  story_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Story', required: true },
  current_chapter_id: { type: mongoose.Schema.Types.ObjectId, ref: 'Chapter', required: true },
  last_read: { type: Date, default: Date.now }
});

// √çndices √∫nicos
ReadingProgressSchema.index({ session_id: 1, story_id: 1 }, { unique: true });

const User = mongoose.model('User', UserSchema);
const Story = mongoose.model('Story', StorySchema);
const Chapter = mongoose.model('Chapter', ChapterSchema);
const Choice = mongoose.model('Choice', ChoiceSchema);
const ReadingProgress = mongoose.model('ReadingProgress', ReadingProgressSchema);

// Inicializar banco de dados
async function initDatabase() {
  console.log('\nüîß Inicializando banco de dados...');
  try {
    // Verificar conex√£o
    const collections = await mongoose.connection.db.listCollections().toArray();
    console.log(`üìã Collections existentes: ${collections.length > 0 ? collections.map(c => c.name).join(', ') : 'Nenhuma (ser√° criada automaticamente)'}`);

    // Criar usu√°rio padr√£o se n√£o existir
    console.log(`\nüîç Verificando usu√°rio admin...`);
    const existingUser = await User.findOne({ username: ADMIN_USERNAME });

    if (!existingUser) {
      console.log('‚è≥ Criando usu√°rio admin...');
      const hashedPassword = await bcrypt.hash(ADMIN_PASSWORD, 10);
      await User.create({
        username: ADMIN_USERNAME,
        password: hashedPassword
      });
      console.log('‚úÖ Usu√°rio padr√£o criado com sucesso!');
      console.log(`   üë§ Username: ${ADMIN_USERNAME}`);
      console.log(`   üîë Password: ${ADMIN_PASSWORD}`);
    } else {
      console.log(`‚úÖ Usu√°rio admin j√° existe (ID: ${existingUser._id})`);
    }

    console.log('\n‚úÖ Banco de dados inicializado com sucesso!\n');
  } catch (err) {
    console.error('\n‚ùå ERRO ao inicializar banco de dados:');
    console.error('Detalhes:', err.message);
    console.error('Stack:', err.stack);
  }
}

// Middlewares
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.use(express.static('public'));
app.use(bodyParser.urlencoded({ extended: true }));
app.use(bodyParser.json());

// Middleware de logging de requisi√ß√µes (√∫til para debug em produ√ß√£o)
app.use((req, res, next) => {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${req.method} ${req.path} - IP: ${req.ip || req.connection.remoteAddress}`);
  next();
});

app.use(session({
  secret: SESSION_SECRET,
  resave: false,
  saveUninitialized: true,
  cookie: {
    maxAge: 30 * 24 * 60 * 60 * 1000, // 30 dias
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax'
  }
}));

// Middleware de autentica√ß√£o
function isAuthenticated(req, res, next) {
  const timestamp = new Date().toISOString();
  if (req.session.userId) {
    console.log(`[${timestamp}] üîì Acesso autorizado - User: ${req.session.username} (${req.session.userId})`);
    next();
  } else {
    console.log(`[${timestamp}] üîí Acesso negado - Redirecionando para login`);
    res.redirect('/secret-admin-login');
  }
}

// ============================================
// ROTAS P√öBLICAS
// ============================================

// P√°gina principal - Grid de hist√≥rias
app.get('/', async (req, res) => {
  try {
    const stories = await Story.aggregate([
      {
        $lookup: {
          from: 'chapters',
          localField: '_id',
          foreignField: 'story_id',
          as: 'chapters'
        }
      },
      {
        $addFields: {
          chapter_count: { $size: '$chapters' },
          id: '$_id'
        }
      },
      {
        $project: {
          chapters: 0
        }
      },
      {
        $sort: { date_created: -1 }
      }
    ]);

    res.render('index', { stories });
  } catch (err) {
    console.error(err);
    res.render('index', { stories: [] });
  }
});

// P√°gina de leitura interativa
app.get('/read/:storyId', async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const sessionId = req.session.id;

    // Buscar a hist√≥ria
    const story = await Story.findById(storyId);
    if (!story) {
      return res.redirect('/');
    }

    // Adicionar campo id para compatibilidade com views
    story.id = story._id;

    // Verificar progresso de leitura
    const progress = await ReadingProgress.findOne({
      session_id: sessionId,
      story_id: storyId
    });

    let chapter;

    if (progress) {
      chapter = await Chapter.findById(progress.current_chapter_id);
    }

    // Se n√£o tem progresso, pegar o primeiro cap√≠tulo
    if (!chapter) {
      chapter = await Chapter.findOne({ story_id: storyId }).sort({ chapter_number: 1 });

      if (!chapter) {
        return res.send('Esta hist√≥ria ainda n√£o tem cap√≠tulos.');
      }
    }

    // Adicionar campo id para compatibilidade
    chapter.id = chapter._id;

    await loadChapterView(res, story, chapter, sessionId);
  } catch (err) {
    console.error(err);
    res.redirect('/');
  }
});

// Fun√ß√£o auxiliar para carregar a view do cap√≠tulo
async function loadChapterView(res, story, chapter, sessionId) {
  try {
    // Buscar as escolhas do cap√≠tulo
    const choices = await Choice.find({ chapter_id: chapter._id }).sort({ order_number: 1 });

    res.render('reader', {
      story,
      chapter,
      choices
    });

    // Atualizar progresso de leitura
    await ReadingProgress.findOneAndUpdate(
      { session_id: sessionId, story_id: story._id },
      {
        current_chapter_id: chapter._id,
        last_read: new Date()
      },
      { upsert: true, new: true }
    );
  } catch (err) {
    console.error('Erro ao carregar cap√≠tulo:', err);
  }
}

// Navegar para pr√≥ximo cap√≠tulo (escolha)
app.post('/read/:storyId/choice', async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const nextChapterId = req.body.nextChapterId;
    const sessionId = req.session.id;

    if (!nextChapterId) {
      return res.redirect(`/read/${storyId}`);
    }

    // Atualizar progresso
    await ReadingProgress.findOneAndUpdate(
      { session_id: sessionId, story_id: storyId },
      {
        current_chapter_id: nextChapterId,
        last_read: new Date()
      },
      { upsert: true, new: true }
    );

    res.redirect(`/read/${storyId}`);
  } catch (err) {
    console.error(err);
    res.redirect(`/read/${req.params.storyId}`);
  }
});

// Resetar progresso de leitura
app.post('/read/:storyId/restart', async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const sessionId = req.session.id;

    await ReadingProgress.deleteOne({
      session_id: sessionId,
      story_id: storyId
    });

    res.redirect(`/read/${storyId}`);
  } catch (err) {
    console.error(err);
    res.redirect(`/read/${req.params.storyId}`);
  }
});

// ============================================
// ROTAS DE AUTENTICA√á√ÉO
// ============================================

app.get('/secret-admin-login', (req, res) => {
  if (req.session.userId) {
    return res.redirect('/admin');
  }
  res.render('login', { error: null });
});

app.post('/login', async (req, res) => {
  const timestamp = new Date().toISOString();
  try {
    const { username, password } = req.body;

    console.log(`\n[${timestamp}] üîê LOGIN - Nova tentativa`);
    console.log(`   üë§ Username fornecido: "${username}"`);
    console.log(`   üîë Senha fornecida: ${password ? '***' + password.slice(-2) : 'vazia'}`);
    console.log(`   üìç IP: ${req.ip || req.connection.remoteAddress}`);

    if (!username || !password) {
      console.log(`[LOGIN] ‚ùå Credenciais vazias`);
      return res.render('login', { error: 'Por favor, preencha usu√°rio e senha' });
    }

    console.log(`[LOGIN] üîç Buscando usu√°rio no MongoDB...`);
    const user = await User.findOne({ username });

    if (!user) {
      console.log(`[LOGIN] ‚ùå Usu√°rio n√£o encontrado: "${username}"`);
      console.log(`[LOGIN] üí° Dica: Verifique se o usu√°rio admin foi criado corretamente`);
      return res.render('login', { error: 'Usu√°rio ou senha inv√°lidos' });
    }

    console.log(`[LOGIN] ‚úÖ Usu√°rio encontrado no banco`);
    console.log(`   üìù ID: ${user._id}`);
    console.log(`   üë§ Username: ${user.username}`);
    console.log(`   üîê Hash da senha armazenada: ${user.password.substring(0, 15)}...`);

    console.log(`[LOGIN] üîì Comparando senhas com bcrypt...`);
    const result = await bcrypt.compare(password, user.password);

    if (result) {
      console.log(`[LOGIN] ‚úÖ‚úÖ‚úÖ Login bem-sucedido para: ${username}`);
      console.log(`[LOGIN] üé´ Criando sess√£o...`);
      req.session.userId = user._id.toString();
      req.session.username = user.username;
      console.log(`[LOGIN] üé´ Session ID: ${req.session.id}`);
      console.log(`[LOGIN] ‚Ü™Ô∏è  Redirecionando para /admin\n`);
      res.redirect('/admin');
    } else {
      console.log(`[LOGIN] ‚ùå Senha incorreta para: ${username}`);
      console.log(`[LOGIN] üí° Senha fornecida n√£o corresponde ao hash armazenado\n`);
      res.render('login', { error: 'Usu√°rio ou senha inv√°lidos' });
    }
  } catch (err) {
    console.error(`\n[${timestamp}] ‚ùå ERRO CR√çTICO NO LOGIN:`);
    console.error('   Mensagem:', err.message);
    console.error('   Stack:', err.stack);
    console.error('');
    res.render('login', { error: 'Erro ao processar login. Verifique os logs do servidor.' });
  }
});

app.get('/logout', (req, res) => {
  req.session.destroy();
  res.redirect('/');
});

// ============================================
// ROTAS ADMINISTRATIVAS
// ============================================

// Painel principal
app.get('/admin', isAuthenticated, async (req, res) => {
  try {
    const stories = await Story.aggregate([
      {
        $lookup: {
          from: 'chapters',
          localField: '_id',
          foreignField: 'story_id',
          as: 'chapters'
        }
      },
      {
        $addFields: {
          chapter_count: { $size: '$chapters' },
          id: '$_id'
        }
      },
      {
        $project: {
          chapters: 0
        }
      },
      {
        $sort: { date_created: -1 }
      }
    ]);

    res.render('admin', { stories, username: req.session.username });
  } catch (err) {
    console.error(err);
    res.render('admin', { stories: [], username: req.session.username });
  }
});

// Formul√°rio de nova hist√≥ria
app.get('/admin/story/new', isAuthenticated, (req, res) => {
  res.render('story-form', { story: null, username: req.session.username });
});

// Formul√°rio de editar hist√≥ria
app.get('/admin/story/edit/:id', isAuthenticated, async (req, res) => {
  try {
    const story = await Story.findById(req.params.id);
    if (!story) {
      return res.redirect('/admin');
    }
    story.id = story._id;
    res.render('story-form', { story, username: req.session.username });
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Salvar hist√≥ria
app.post('/admin/story/save', isAuthenticated, async (req, res) => {
  try {
    const { id, title, description, cover_color, genre, status } = req.body;

    if (id) {
      // Atualizar
      await Story.findByIdAndUpdate(id, {
        title,
        description,
        cover_color: cover_color || '#2d2d2d',
        genre,
        status,
        date_updated: new Date()
      });
      res.redirect('/admin/story/' + id + '/chapters');
    } else {
      // Criar nova
      const newStory = await Story.create({
        title,
        description,
        cover_color: cover_color || '#2d2d2d',
        genre,
        status
      });
      res.redirect('/admin/story/' + newStory._id + '/chapters');
    }
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Excluir hist√≥ria
app.post('/admin/story/delete/:id', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.id;

    // Buscar todos os cap√≠tulos da hist√≥ria
    const chapters = await Chapter.find({ story_id: storyId });
    const chapterIds = chapters.map(c => c._id);

    // Deletar todas as escolhas relacionadas aos cap√≠tulos
    await Choice.deleteMany({ chapter_id: { $in: chapterIds } });

    // Deletar todos os cap√≠tulos
    await Chapter.deleteMany({ story_id: storyId });

    // Deletar progresso de leitura
    await ReadingProgress.deleteMany({ story_id: storyId });

    // Deletar a hist√≥ria
    await Story.findByIdAndDelete(storyId);

    res.redirect('/admin');
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Gerenciar cap√≠tulos
app.get('/admin/story/:storyId/chapters', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const story = await Story.findById(storyId);

    if (!story) {
      return res.redirect('/admin');
    }

    story.id = story._id;

    const chapters = await Chapter.find({ story_id: storyId }).sort({ chapter_number: 1 });

    // Adicionar campo id para cada cap√≠tulo
    const chaptersWithId = chapters.map(ch => {
      const chObj = ch.toObject();
      chObj.id = ch._id;
      return chObj;
    });

    res.render('chapters', { story, chapters: chaptersWithId, username: req.session.username });
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Formul√°rio de novo cap√≠tulo
app.get('/admin/story/:storyId/chapter/new', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const story = await Story.findById(storyId);

    if (!story) {
      return res.redirect('/admin');
    }

    story.id = story._id;

    // Buscar pr√≥ximo n√∫mero de cap√≠tulo
    const lastChapter = await Chapter.findOne({ story_id: storyId }).sort({ chapter_number: -1 });
    const nextNumber = lastChapter ? lastChapter.chapter_number + 1 : 1;

    res.render('chapter-form', {
      story,
      chapter: null,
      nextNumber,
      username: req.session.username
    });
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Formul√°rio de editar cap√≠tulo
app.get('/admin/story/:storyId/chapter/edit/:chapterId', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const chapterId = req.params.chapterId;

    const story = await Story.findById(storyId);
    if (!story) {
      return res.redirect('/admin');
    }

    const chapter = await Chapter.findById(chapterId);
    if (!chapter) {
      return res.redirect('/admin/story/' + storyId + '/chapters');
    }

    story.id = story._id;
    chapter.id = chapter._id;

    res.render('chapter-form', {
      story,
      chapter,
      nextNumber: chapter.chapter_number,
      username: req.session.username
    });
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Salvar cap√≠tulo
app.post('/admin/story/:storyId/chapter/save', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const { id, chapter_number, title, content, is_ending } = req.body;

    if (id) {
      // Atualizar
      await Chapter.findByIdAndUpdate(id, {
        chapter_number,
        title,
        content,
        is_ending: is_ending ? true : false
      });
      res.redirect('/admin/story/' + storyId + '/chapter/' + id + '/choices');
    } else {
      // Criar
      const newChapter = await Chapter.create({
        story_id: storyId,
        chapter_number,
        title,
        content,
        is_ending: is_ending ? true : false
      });
      res.redirect('/admin/story/' + storyId + '/chapter/' + newChapter._id + '/choices');
    }
  } catch (err) {
    console.error(err);
    res.redirect('/admin/story/' + req.params.storyId + '/chapters');
  }
});

// Excluir cap√≠tulo
app.post('/admin/story/:storyId/chapter/delete/:chapterId', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const chapterId = req.params.chapterId;

    // Deletar escolhas relacionadas
    await Choice.deleteMany({ chapter_id: chapterId });

    // Deletar refer√™ncias em outras escolhas
    await Choice.updateMany(
      { next_chapter_id: chapterId },
      { $unset: { next_chapter_id: "" } }
    );

    // Deletar o cap√≠tulo
    await Chapter.findByIdAndDelete(chapterId);

    res.redirect('/admin/story/' + storyId + '/chapters');
  } catch (err) {
    console.error(err);
    res.redirect('/admin/story/' + req.params.storyId + '/chapters');
  }
});

// Gerenciar escolhas de um cap√≠tulo
app.get('/admin/story/:storyId/chapter/:chapterId/choices', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const chapterId = req.params.chapterId;

    const story = await Story.findById(storyId);
    if (!story) {
      return res.redirect('/admin');
    }

    const chapter = await Chapter.findById(chapterId);
    if (!chapter) {
      return res.redirect('/admin/story/' + storyId + '/chapters');
    }

    const choices = await Choice.find({ chapter_id: chapterId }).sort({ order_number: 1 });
    const allChapters = await Chapter.find({ story_id: storyId }).sort({ chapter_number: 1 });

    // Adicionar campo id
    story.id = story._id;
    chapter.id = chapter._id;

    const choicesWithId = choices.map(ch => {
      const chObj = ch.toObject();
      chObj.id = ch._id;
      return chObj;
    });

    const allChaptersWithId = allChapters.map(ch => {
      const chObj = ch.toObject();
      chObj.id = ch._id;
      return chObj;
    });

    res.render('choices', {
      story,
      chapter,
      choices: choicesWithId,
      allChapters: allChaptersWithId,
      username: req.session.username
    });
  } catch (err) {
    console.error(err);
    res.redirect('/admin');
  }
});

// Adicionar escolha
app.post('/admin/story/:storyId/chapter/:chapterId/choice/add', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const chapterId = req.params.chapterId;
    const { choice_text, next_chapter_id, order_number } = req.body;

    await Choice.create({
      chapter_id: chapterId,
      choice_text,
      next_chapter_id: next_chapter_id || null,
      order_number: order_number || 0
    });

    res.redirect('/admin/story/' + storyId + '/chapter/' + chapterId + '/choices');
  } catch (err) {
    console.error(err);
    res.redirect('/admin/story/' + req.params.storyId + '/chapter/' + req.params.chapterId + '/choices');
  }
});

// Excluir escolha
app.post('/admin/story/:storyId/chapter/:chapterId/choice/delete/:choiceId', isAuthenticated, async (req, res) => {
  try {
    const storyId = req.params.storyId;
    const chapterId = req.params.chapterId;
    const choiceId = req.params.choiceId;

    await Choice.findByIdAndDelete(choiceId);

    res.redirect('/admin/story/' + storyId + '/chapter/' + chapterId + '/choices');
  } catch (err) {
    console.error(err);
    res.redirect('/admin/story/' + req.params.storyId + '/chapter/' + req.params.chapterId + '/choices');
  }
});

// ============================================
// TRATAMENTO DE ERROS GLOBAL
// ============================================

// Capturar erros 404
app.use((req, res) => {
  console.log(`‚ùå 404 - Rota n√£o encontrada: ${req.method} ${req.path}`);
  res.status(404).send(`
    <!DOCTYPE html>
    <html>
      <head><title>404 - P√°gina n√£o encontrada</title></head>
      <body style="font-family: Arial; padding: 50px; text-align: center;">
        <h1>‚ùå P√°gina n√£o encontrada</h1>
        <p>A rota <code>${req.path}</code> n√£o existe.</p>
        <a href="/">‚Üê Voltar para p√°gina inicial</a>
      </body>
    </html>
  `);
});

// Capturar erros gerais
app.use((err, req, res, next) => {
  const timestamp = new Date().toISOString();
  console.error(`\n[${timestamp}] ‚ùå ERRO NO SERVIDOR:`);
  console.error('URL:', req.method, req.path);
  console.error('Mensagem:', err.message);
  console.error('Stack:', err.stack);
  console.error('');

  res.status(500).send(`
    <!DOCTYPE html>
    <html>
      <head><title>500 - Erro no Servidor</title></head>
      <body style="font-family: Arial; padding: 50px; text-align: center;">
        <h1>‚ö†Ô∏è Erro no Servidor</h1>
        <p>Ocorreu um erro ao processar sua requisi√ß√£o.</p>
        <p><small>${process.env.NODE_ENV === 'development' ? err.message : 'Verifique os logs do servidor'}</small></p>
        <a href="/">‚Üê Voltar para p√°gina inicial</a>
      </body>
    </html>
  `);
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log('\n' + '='.repeat(70));
  console.log('üåü SERVIDOR DE HIST√ìRIAS INTERATIVAS INICIADO COM SUCESSO!');
  console.log('='.repeat(70));
  console.log(`üìç Ambiente: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üöÄ Porta: ${PORT}`);
  console.log(`üìñ P√°gina principal: http://localhost:${PORT}`);
  console.log(`üîê √Årea administrativa: http://localhost:${PORT}/secret-admin-login`);
  console.log(`üë§ Credenciais padr√£o: ${ADMIN_USERNAME} / ${ADMIN_PASSWORD}`);
  console.log(`üóÑÔ∏è  MongoDB: ${mongoose.connection.readyState === 1 ? 'Conectado ‚úÖ' : 'Desconectado ‚ùå'}`);
  console.log(`üóÑÔ∏è  Database: history_interactive`);
  console.log('='.repeat(70));
  console.log('\nüí° Para testar o login:');
  console.log(`   1. Acesse: http://localhost:${PORT}/secret-admin-login`);
  console.log(`   2. Use: ${ADMIN_USERNAME} / ${ADMIN_PASSWORD}`);
  console.log(`   3. Ou pressione 'h' 10x na p√°gina inicial\n`);
  console.log('üìä Logs detalhados est√£o ativados - Monitorando requisi√ß√µes...\n');
});
